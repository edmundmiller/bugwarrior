{"id":"bugwarrior-1xp","title":"Two-way sync for Apple Reminders","description":"## Problem\n\nBugwarrior is a one-way sync tool - it pulls issues from external services into Taskwarrior but never pushes changes back. For Apple Reminders specifically, this is limiting because:\n\n1. Marking a reminder done in Taskwarrior has no effect on the actual reminder\n2. The reminder stays open in Apple Reminders, causing it to get reopened on next sync\n3. Users must update both systems manually\n\nFor personal reminders (unlike GitHub/Jira where you want review before closing), automatic two-way sync is desirable.\n\n## Solution\n\nAdd write-back capability to Apple Reminders service that marks reminders as completed when their corresponding Taskwarrior tasks are completed.\n\n## Implementation Plan\n\n### Phase 1: Add Completion Write-back to AppleRemindersClient\n\n1. **Add `complete_reminder()` method** (`applereminders.py`)\n   ```python\n   def complete_reminder(self, reminder_id: str) -\u003e bool:\n       \"\"\"Mark a reminder as completed in Apple Reminders.\"\"\"\n       # Fetch reminder by ID\n       # Set isCompleted = True\n       # Set completionDate = now\n       # Save changes via event_store.saveReminder_commit_error_()\n       # Return success/failure\n   ```\n\n2. **Add `get_reminder_by_id()` helper method**\n   - Use `calendarItemWithIdentifier_` to fetch specific reminder\n   - Handle case where reminder was deleted\n\n### Phase 2: Integrate with Sync Process\n\n1. **Add service-level write-back interface** (`services/__init__.py`)\n   - Define optional `complete_issue(issue_key)` method on Service base class\n   - Default implementation returns False (not supported)\n\n2. **Implement in AppleRemindersService**\n   ```python\n   def complete_issue(self, issue_key: str) -\u003e bool:\n       \"\"\"Mark the upstream issue as completed.\"\"\"\n       return self.client.complete_reminder(issue_key)\n   ```\n\n3. **Modify sync logic** (`db.py`)\n   - **Recommended approach:** Add a new sync phase AFTER normal sync\n   - Find tasks that are:\n     - Managed by a service with `two_way_sync` enabled\n     - Marked completed in Taskwarrior\n     - Have a valid upstream ID (e.g., `appleremindersid`)\n     - Upstream issue is still open (exists in current sync results)\n   - For each, call `service.complete_issue(upstream_id)`\n   - Log the action: \"Marking upstream issue complete: Apple Reminder XYZ\"\n\n### Phase 3: Configuration\n\n1. **Add config option** (`config/schema.py`)\n   ```python\n   class AppleRemindersConfig(config.ServiceConfig):\n       ...\n       two_way_sync: bool = False  # Default off for safety\n   ```\n\n2. **Document the feature** (`docs/services/applereminders.rst`)\n   - Explain two-way sync behavior\n   - Note that it's opt-in (must set `two_way_sync = true`)\n   - Explain recurring reminder behavior\n\n## Key Technical Details\n\n### EventKit Write Operations\n\n```python\n# Get reminder by ID\nreminder = self.event_store.calendarItemWithIdentifier_(reminder_id)\n\nif not reminder:\n    log.warning(f\"Reminder {reminder_id} not found (may have been deleted)\")\n    return False\n\n# Mark as completed\nreminder.setCompleted_(True)\nreminder.setCompletionDate_(NSDate.date())\n\n# Save changes\nerror = None\nsuccess = self.event_store.saveReminder_commit_error_(reminder, True, error)\n\nif not success:\n    log.error(f\"Failed to complete reminder: {error}\")\n    return False\n\nreturn True\n```\n\n### Edge Cases to Handle\n\n1. **Reminder deleted upstream** - Log warning, proceed with local task closure (it's already \"done\")\n2. **Permission denied** - Request write access during init, fail gracefully if denied\n3. **Sync conflict** - If reminder was modified upstream since last sync, warn but still complete\n4. **Recurring reminders** - Current behavior is acceptable:\n   - Completing marks current instance done\n   - Next occurrence becomes a new reminder\n   - That new reminder gets pulled in as a new task on next sync\n   - **Future enhancement**: Properly map recurring reminders to Taskwarrior recurrence (separate issue)\n\n### Safety Considerations\n\n- Default `two_way_sync = false` - must be explicitly enabled\n- Only affects Apple Reminders (personal data, low risk)\n- Log all write operations for audit trail\n- Dry-run mode should show what would be completed without doing it\n- Write operations happen AFTER read sync completes successfully\n\n## Files to Modify\n\n- `bugwarrior/services/applereminders.py` - Add write methods\n- `bugwarrior/services/__init__.py` - Add optional `complete_issue` interface\n- `bugwarrior/db.py` - Integrate write-back into sync process\n- `bugwarrior/config/schema.py` - Add `two_way_sync` config option\n- `bugwarrior/docs/services/applereminders.rst` - Document feature\n\n## Testing\n\n- Unit tests for `complete_reminder()` method (mock EventKit)\n- Integration test for full sync cycle with two-way sync enabled\n- Test edge cases: deleted reminder, permission denied, recurring reminder\n- Test dry-run mode doesn't actually complete reminders\n\n## Acceptance Criteria\n\n- [ ] `complete_reminder()` method works via EventKit\n- [ ] Config option `two_way_sync` controls feature (default off)\n- [ ] Completing task in Taskwarrior marks Apple Reminder done on next sync\n- [ ] Proper logging of write operations\n- [ ] Dry-run mode shows planned completions without executing\n- [ ] Graceful handling of deleted/inaccessible reminders\n- [ ] Recurring reminders: completing one instance works correctly (next occurrence creates new task)\n\n## Future Enhancements\n\n**Recurring Reminders (Separate Issue):**\n- Properly map Apple Reminders recurrence rules to Taskwarrior recurrence\n- Currently, recurring reminders create new tasks for each occurrence\n- Goal: Have one recurring task in Taskwarrior that matches the reminder's recurrence pattern\n- This requires deeper integration with Taskwarrior's recurrence system","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-13T15:40:18.888196-06:00","updated_at":"2025-12-13T15:51:46.341642-06:00","labels":["feature"]}
{"id":"bugwarrior-697","title":"Warn when locally-completed tasks are reopened by upstream","description":"## Problem\n\nWhen a user marks a task as \"done\" in Taskwarrior but the underlying issue remains open in the upstream tracker (GitHub, Jira, Apple Reminders, etc.), `bugwarrior pull` silently reopens the task. This happens in `db.py:327-330`:\n\n```python\nif task[\"status\"] == \"completed\":\n    # Reopen task\n    task[\"status\"] = \"pending\"\n    task[\"end\"] = None\n```\n\nThere is no logging, notification, or warning - the task just silently gets reopened. This creates confusion when users think they completed work but find it back in their queue.\n\n**User wants:** Instead of reopening the task, warn them that the issue is still open upstream and they should close it there. Be annoying about it until they actually close the upstream issue.\n\n## Solution\n\nWhen a completed task in Taskwarrior matches an open issue upstream:\n1. **Skip the reopen** - leave the task completed in Taskwarrior\n2. **Warn the user EVERY sync** - display a clear, annoying warning until they close it\n3. **Provide actionable info** - include service name, issue ID/URL for easy navigation\n\n## Implementation Plan\n\n### Core Logic Changes (`db.py`)\n\n1. **Track diverged tasks instead of reopening**\n   - Add `issue_updates[\"diverged\"] = []` to track completed-local-but-open-upstream tasks\n   - When a completed task is found (line 327), **do NOT reopen it**\n   - Instead, append it to `diverged` list with context:\n     ```python\n     if task[\"status\"] == \"completed\":\n         # Task is completed locally but issue is still open upstream\n         issue_updates[\"diverged\"].append({\n             \"uuid\": existing_taskwarrior_uuid,\n             \"task\": task,\n             \"issue\": issue,\n             \"service\": service_config.service,\n         })\n         # Skip this task - don't update it or reopen it\n         continue\n     ```\n\n2. **Report diverged tasks to user (EVERY TIME - be annoying!)**\n   - After sync completes, display warnings for diverged tasks\n   - **Always show the list with URLs** - warn every single sync until they close it\n   - Format:\n     ```\n     ‚ö†Ô∏è  WARNING: The following tasks are completed locally but still open upstream:\n     \n     GitHub (my_project):\n       ‚Ä¢ \"Fix login bug\" (#123)\n         üëâ https://github.com/user/repo/issues/123\n     \n     Apple Reminders (Shopping):\n       ‚Ä¢ \"Buy groceries\"\n         üëâ Open Apple Reminders app to mark complete\n     \n     Jira (PROJ):\n       ‚Ä¢ \"Deploy to production\" (PROJ-789)\n         üëâ https://jira.company.com/browse/PROJ-789\n     \n     ‚ö†Ô∏è  Please close these issues upstream. This warning will repeat until you do.\n     ```\n   - Use `log.warning()` for prominent display\n   - **Extract URLs from issues** - most services have URL UDAs (githuburl, jiraurl, appleremindersurl, etc.)\n\n3. **Handle the skip properly**\n   - When a task is added to `diverged`, use `continue` to skip further processing\n   - Don't add it to `changed`, `existing`, or any other category\n   - Don't call `tw.task_update()` for diverged tasks - leave them completed\n\n### Optional: Config for Old Behavior (Low Priority)\n\nAdd a config option for backwards compatibility:\n\n```toml\n[general]\n# How to handle tasks completed locally but still open upstream\n# - \"warn\": Skip reopen, warn user (default, recommended)\n# - \"reopen\": Silently reopen (old behavior - surprising and not recommended)\ndivergence_handling = \"warn\"\n```\n\n**Note:** The old `reopen` behavior is surprising and often unwanted - users mark tasks done intentionally and expect them to stay done. The new `warn` behavior respects local changes while still keeping the user informed.\n\n### Future Enhancement: Desktop Notifications (P3)\n\nAdd desktop notification support for diverged tasks:\n- New notification type: `send_notification(issue, \"Diverged\", conf[\"notifications\"])`\n- Config option: `notify_on_divergence = true` (default false)\n- Would use existing notification system (applescript/gobject/growlnotify)\n- Lower priority since terminal output during sync is usually visible\n\n## Files to Modify\n\n- `bugwarrior/db.py` - Main sync logic, prevent reopen and track diverged tasks\n- `bugwarrior/config/schema.py` - (Optional, low priority) Add `divergence_handling` config option\n\n## URL Extraction Strategy\n\nServices store URLs in UDAs:\n- GitHub: `githuburl`\n- Jira: `jiraurl`  \n- Apple Reminders: `appleremindersurl`\n- GitLab: `gitlaburl`\n- etc.\n\nExtract URL from task like:\n```python\nurl = task.get(f\"{service}url\") or task.get(\"url\") or \"(no URL available)\"\n```\n\n## Testing\n\n- Add test case in `tests/test_db.py` for divergence detection\n- Mock scenario: task completed locally, issue still returned from service\n- Verify:\n  - Task remains completed\n  - Warning is logged with URL\n  - Task not in changed/existing/new/closed categories\n  - Warning repeats on subsequent syncs\n\n## Acceptance Criteria\n\n- [ ] Completed tasks are NOT reopened when upstream issue is still open\n- [ ] Warning displayed for EVERY diverged task on EVERY sync (be annoying!)\n- [ ] Warning includes issue URL for easy clicking\n- [ ] Clear message that warning will repeat until issue is closed\n- [ ] Task remains in completed state locally\n- [ ] (Optional, low priority) Config option to restore old reopen behavior for backwards compat\n\n## Design Note\n\nThe old auto-reopen behavior is **surprising and often unwanted**. Users mark tasks done intentionally and expect them to stay done. If they forgot to close the upstream issue, a persistent warning is more helpful than silently undoing their work.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-13T15:40:18.881898-06:00","updated_at":"2025-12-13T15:51:09.835138-06:00","labels":["feature"]}
{"id":"bugwarrior-84u","title":"1password is called 10 times - should be cached/called once","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T08:51:24.634176-06:00","updated_at":"2025-12-10T10:22:17.386889-06:00","closed_at":"2025-12-10T10:22:17.386889-06:00","labels":["feature"]}
{"id":"bugwarrior-bsl","title":"Spinner to checkmark transition causes visual jump to the right","description":"When a service completes, the spinner (‚†ã) changes to a checkmark (‚úì), but the checkmark appears shifted to the right compared to the spinner position. This creates a visual 'jump' effect. The checkmark and spinner should be aligned.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-10T09:32:44.825498-06:00","updated_at":"2025-12-10T09:38:22.53475-06:00","labels":["bug"]}
{"id":"bugwarrior-e4q","title":"Map Apple Reminders recurrence to Taskwarrior recurrence properly","description":"## Problem\n\nCurrently, recurring Apple Reminders are not mapped to Taskwarrior's recurrence system. Instead:\n\n1. Each occurrence of a recurring reminder appears as a separate task\n2. Completing one instance in Taskwarrior doesn't affect the recurrence pattern\n3. The next occurrence creates a brand new task on the next sync\n4. You end up with multiple completed tasks for the same recurring reminder\n\nThis clutters Taskwarrior and doesn't leverage its built-in recurrence capabilities.\n\n## Current State\n\nApple Reminders service already extracts recurrence information:\n- Stored in `appleremindersrecurrence` UDA (line 623 in `applereminders.py`)\n- Format: \"daily\", \"weekly\", \"every 2 weeks\", \"monthly\", \"yearly\"\n- Also stored as annotation for visibility (line 733)\n\nBut Taskwarrior doesn't know this is a recurring task - it sees each instance as independent.\n\n## Goal\n\nMap Apple Reminders recurrence rules to Taskwarrior's native recurrence format so:\n- One task represents the recurring reminder\n- Completing one instance creates the next one automatically (Taskwarrior behavior)\n- Recurrence pattern is preserved and visible in Taskwarrior\n\n## Implementation Plan\n\n### Phase 1: Recurrence Rule Parsing\n\n1. **Parse Apple Reminders recurrence format** (`applereminders.py`)\n   - Current format from `_format_recurrence_rule()`: \"daily\", \"weekly\", \"every 2 weeks until 2025-01-01\"\n   - Need to parse this into Taskwarrior format\n   - Taskwarrior recurrence syntax: `1day`, `2weeks`, `1month`, `yearly`, etc.\n\n2. **Map to Taskwarrior recurrence**\n   ```python\n   def _convert_recurrence_to_taskwarrior(self, recurrence_string):\n       \"\"\"Convert Apple Reminders recurrence to Taskwarrior format.\"\"\"\n       # \"daily\" -\u003e \"1day\"\n       # \"weekly\" -\u003e \"1week\"  \n       # \"every 2 weeks\" -\u003e \"2weeks\"\n       # \"monthly\" -\u003e \"1month\"\n       # \"yearly\" -\u003e \"1year\"\n       # Handle until/count if present\n   ```\n\n### Phase 2: Apply Recurrence in Task Creation\n\n1. **Set recurrence in task dict** (`AppleRemindersIssue.to_taskwarrior()`)\n   ```python\n   if self.config.import_recurrence and self.record.get(\"recurrence\"):\n       # Convert to Taskwarrior format\n       tw_recurrence = self._convert_recurrence_to_taskwarrior(\n           self.record[\"recurrence\"]\n       )\n       task[\"recur\"] = tw_recurrence\n       \n       # Also set until/wait if applicable\n       if self.record.get(\"recurrence_end\"):\n           task[\"until\"] = self._get_formatted_date(\n               self.record[\"recurrence_end\"]\n           )\n   ```\n\n2. **Handle parent/child task relationship**\n   - Taskwarrior creates parent task (template) and child tasks (instances)\n   - Parent has `recur` field, children have `parent` UUID\n   - When syncing, need to match against parent task, not children\n\n### Phase 3: Sync Logic for Recurring Tasks\n\n**Challenge:** How to match recurring reminder instances to Taskwarrior recurring task?\n\n**Approach A - Match by reminder ID (current):**\n- Each occurrence has a different ID in Apple Reminders\n- This creates separate tasks (current behavior)\n- Would need to track parent reminder ID somehow\n\n**Approach B - Match by title + list (safer):**\n- Use title + list as unique key for recurring reminders\n- First occurrence creates the parent task with recurrence\n- Subsequent occurrences match the same parent task\n- Risk: If you have multiple reminders with same title\n\n**Approach C - Use reminder series ID (best, if available):**\n- Check if EventKit exposes a \"series ID\" for recurring reminders\n- Use that as the unique identifier\n- All instances of same recurring reminder share the series ID\n\n**Recommended:** Start with Approach B for MVP, investigate Approach C for robustness.\n\n### Phase 4: Handle Completion of Recurring Tasks\n\nWith two-way sync (issue `bugwarrior-1xp`):\n- Completing a child task in Taskwarrior should complete that occurrence in Apple Reminders\n- But NOT delete the recurrence rule\n- Taskwarrior automatically creates next child task\n- That task should NOT sync back to Apple (Apple already has next occurrence)\n\nThis requires careful logic to avoid double-creating tasks.\n\n## Technical Details\n\n### EventKit Recurrence Information\n\nCurrent implementation in `_format_recurrence_rule()` (lines 529-561):\n- Extracts frequency: daily/weekly/monthly/yearly\n- Extracts interval: 1, 2, 3, etc.\n- Extracts end condition: date or count\n- Need to also extract: daysOfWeek, daysOfMonth, etc.\n\n### Taskwarrior Recurrence Syntax\n\n```\nrecur: 1day, 2weeks, 3months, yearly\nuntil: YYYYMMDDTHHMMSSZ (optional end date)\n```\n\n### Enhanced Recurrence Parsing Needed\n\n```python\ndef _format_recurrence_rule(self, rule):\n    \"\"\"Format EKRecurrenceRule with full Taskwarrior compatibility.\"\"\"\n    frequency_map = {0: \"day\", 1: \"week\", 2: \"month\", 3: \"year\"}\n    freq = frequency_map.get(rule.frequency())\n    interval = rule.interval()\n    \n    # Build Taskwarrior recur string\n    recur = f\"{interval}{freq}\"\n    \n    # Extract end date if exists\n    until = None\n    if rule.recurrenceEnd() and rule.recurrenceEnd().endDate():\n        until = self._format_nsdate(rule.recurrenceEnd().endDate())\n    \n    return {\n        \"recur\": recur,\n        \"until\": until,\n        # Future: daysOfWeek, daysOfMonth, etc.\n    }\n```\n\n## Files to Modify\n\n- `bugwarrior/services/applereminders.py` - Enhanced recurrence parsing and task creation\n- `bugwarrior/db.py` - Handle matching recurring tasks (if needed)\n\n## Testing\n\n- Create recurring reminder in Apple Reminders (daily, weekly, monthly)\n- Sync with bugwarrior\n- Verify single parent task created in Taskwarrior with correct `recur` field\n- Complete one instance in Taskwarrior\n- Verify next instance appears automatically (Taskwarrior behavior)\n- With two-way sync: verify completion syncs back to Apple correctly\n\n## Open Questions\n\n1. **Series ID**: Does EventKit expose a series/parent ID for recurring reminders?\n2. **Match strategy**: Which matching approach (A/B/C) to use?\n3. **Two-way interaction**: How to prevent double-creation with two-way sync?\n4. **Config option**: Should recurrence mapping be opt-in or default behavior?\n\n## Acceptance Criteria\n\n- [ ] Recurring Apple Reminders create single recurring task in Taskwarrior\n- [ ] Recurrence pattern correctly mapped (daily/weekly/monthly/yearly)\n- [ ] Interval correctly preserved (every 2 weeks, etc.)\n- [ ] End date/count mapped to Taskwarrior `until` field (if present)\n- [ ] Completing instance works correctly with Taskwarrior's recurrence system\n- [ ] Two-way sync doesn't create duplicate tasks for next occurrence","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-13T15:51:51.565971-06:00","updated_at":"2025-12-13T15:52:30.51991-06:00","labels":["enhancement"]}
{"id":"bugwarrior-i75","title":"Need to run task sync after bugwarrior pull","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T08:51:23.739455-06:00","updated_at":"2025-12-10T09:38:33.294351-06:00","labels":["feature"]}
{"id":"bugwarrior-ol1","title":"Spinners are broken and don't stop when they're done","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T08:51:23.157002-06:00","updated_at":"2025-12-10T09:32:40.949396-06:00","closed_at":"2025-12-10T09:32:40.949396-06:00"}
